/**
 * @id c/misra/generic-association-with-unselectable-type
 * @name RULE-23-4: A generic association shall list an appropriate type
 * @description Generic selections undergo lvalue conversion before type comparison, leading to
 *              certain types being impossible to select.
 * @kind problem
 * @precision very-high
 * @problem.severity error
 * @tags external/misra/id/rule-23-4
 *       correctness
 *       external/misra/c/2012/amendment3
 *       external/misra/obligation/required
 */

import cpp
import codingstandards.c.misra
import codingstandards.cpp.types.LvalueConversion
import codingstandards.cpp.types.Graph
import codingstandards.cpp.alertreporting.DeduplicateMacroResults

/**
 * Check if a type contains an unmatchable anonymous struct or union.
 *
 * Anonymous structs and unions are only equal to themselves. So any anonymous struct, or compound
 * type containing an anonymous struct, is unmatchable.
 *
 * However, there is an exception if the anonymous struct is behind a typedef. All uses of that
 * typedef will resolve to the same anonymous struct, and so the typedef is matchable.
 */
predicate containsAnonymousType(Type t) {
  t.(Struct).isAnonymous()
  or
  not t instanceof TypedefType and
  exists(Type next | typeGraph(t, next) | containsAnonymousType(next))
}

predicate invalidType(Type t, string reason) {
  containsAnonymousType(t) and
  reason = "containing an anonymous struct or union type"
  or
  exists(performLvalueConversion(t, reason))
}

class InvalidSelection extends Expr {
  Type selectionType;
  int idx;
  C11GenericExpr generic;
  string reason;

  InvalidSelection() {
    this = generic.getAssociationExpr(idx) and
    selectionType = generic.getAssociationType(idx) and
    invalidType(selectionType, reason)
  }

  Type getSelectionType() { result = selectionType }

  string getReason() { result = reason }
}

module InvalidSelectionConfig implements DeduplicateMacroConfigSig<InvalidSelection> {
  string describe(InvalidSelection e) {
    result = "'" + e.getSelectionType().toString() + "', due to " + e.getReason()
  }
}

import InvalidSelectionConfig

module InvalidSelectionReportConfig implements MacroReportConfigSig<InvalidSelection> {
  /* Create a message to describe this macro, with a string describing its `ResultElement`. */
  bindingset[description]
  string getMessageSameResultInAllExpansions(Macro m, string description) {
    result = "Generic in macro " + m.getName() + " has unselectable type " + description + "."
  }

  /* Create a message to describe this macro, using '$@' to describe an example `ResultElement`. */
  string getMessageVariedResultInAllExpansions(Macro m) {
    result =
      "Generic in macro " + m.getName() +
        " has an invocation-dependent unselectable type, for example $@."
  }

  /**
   * Create a message to describe this macro expansion which produces a `ResultElement`, using '$@'
   * to describe the relevant macro.
   */
  string getMessageResultInIsolatedExpansion(InvalidSelection element) {
    result =
      "Generic resulting from invocation of macro $@ contains an unselectable type " +
        describe(element) + "."
  }

  /**
   * Create a message to describe a `ResultElement` which is not generated by a macro expansion.
   */
  string getMessageNotInMacro(InvalidSelection element, Locatable optLoc1, string optStr1) {
    result = "Generic selection uses unselectable type " + describe(element) + "'." and
    optLoc1 = element and
    optStr1 = "side effect"
  }
}

import DeduplicateMacroResults<InvalidSelection, InvalidSelectionConfig> as Deduplicate
import Deduplicate::Report<InvalidSelectionReportConfig> as Report

from Report::ReportResult res
where
  not isExcluded(res.getPrimaryElement(),
    GenericsPackage::genericSelectionNotFromMacroWithSideEffectsQuery())
select res.getPrimaryElement(), res.getMessage(), res.getOptionalPlaceholderLocatable(),
  res.getOptionalPlaceholderMessage()
